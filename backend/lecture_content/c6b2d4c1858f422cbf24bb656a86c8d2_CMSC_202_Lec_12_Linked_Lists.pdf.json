{
  "deck_title": "CMSC202 Â· Linked Lists",
  "topics": [
    {
      "summary_text": "Linked lists are dynamic data structures that allow efficient insertion and deletion of elements. They consist of nodes, where each node contains data and a pointer to the next node."
    },
    {
      "summary_text": "Vectors use contiguous memory, making insertions/deletions in the middle costly. Linked lists avoid this, but can't randomly access elements and require pointer management."
    },
    {
      "summary_text": "A node is a basic element of a linked list, containing data and a pointer to the next node. Nodes are often implemented as classes or structs."
    },
    {
      "summary_text": "The last node in a linked list points to `nullptr`. Each node points to the next node, or `nullptr`. There is only one link per node."
    },
    {
      "summary_text": "It is important to manage memory properly with linked lists to avoid losing nodes. Special cases such as empty lists, single-element lists, and changes to the first or last node need to be considered."
    },
    {
      "summary_text": "Essential linked list functions include the constructor, `insert()`, `remove()`, `printList()`, and `isEmpty()`."
    },
    {
      "summary_text": "The linked list constructor initializes the `m_head` to `nullptr`. More functionally, `m_tail` is also initialized to `nullptr` and `m_size` is set to `0`."
    },
    {
      "summary_text": "Inserting a node involves creating a new node, populating its data, and linking it to the list. Insertion can occur at the beginning, end, or middle."
    },
    {
      "summary_text": "Traversing a linked list involves iterating through each node, typically to access or modify the data. This is done using a temporary pointer that moves from node to node."
    },
    {
      "summary_text": "Removing a node from a linked list requires updating the previous node's pointer to skip the node being removed to maintain the list's integrity. The removed node's memory is then deallocated."
    },
    {
      "summary_text": "Dummy nodes at the beginning and end can simplify linked list operations by eliminating edge cases like empty lists. Dummy nodes don't contribute to the size count."
    },
    {
      "summary_text": "Reversing a linked list in place requires updating each node's `m_next` pointer to point to the previous node. This involves using three pointers: `curr`, `prev`, and `next`."
    }
  ]
}
