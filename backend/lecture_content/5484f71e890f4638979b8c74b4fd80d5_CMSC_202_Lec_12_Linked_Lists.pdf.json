{
  "deck_title": "CMSC202 Â· Linked Lists",
  "topics": [
    {
      "summary_text": "Linked lists are dynamic data structures that allow easy insertion and deletion of elements. They consist of nodes, each containing data and a pointer to the next node."
    },
    {
      "summary_text": "Vectors use contiguous memory, making insertions/deletions in the middle costly. Linked lists only require contiguous storage for each node, making insertions/deletions easier."
    },
    {
      "summary_text": "Linked lists allow easy resizing and insertion/deletion, but accessing elements requires sequential iteration. Memory management is manual, and pointers consume extra memory."
    },
    {
      "summary_text": "A node is a linked list element, storing data and a pointer to the next node. Nodes are commonly implemented as classes with data members and a pointer (m_next) to another node."
    },
    {
      "summary_text": "The last node's pointer (m_next) points to `nullptr`. Each node points to either another node or `nullptr`. There's only one link per node."
    },
    {
      "summary_text": "Linked lists require careful memory management to prevent lost nodes (memory leaks). Think of it like a train; losing a link can detach part of the list."
    },
    {
      "summary_text": "Be aware of special cases like empty lists, single-element lists, or changes to the first/last node when coding. Dummy nodes can simplify these scenarios."
    },
    {
      "summary_text": "Essential linked list functions include a constructor, insert(), remove(), printList(), and isEmpty(). Remember to handle memory deallocation when the list is no longer needed."
    },
    {
      "summary_text": "The constructor initializes the head pointer (m_head) to `nullptr`, indicating an empty list. Enhanced constructors may also initialize a tail pointer (m_tail) and size counter."
    },
    {
      "summary_text": "Inserting a node involves creating a new node, populating its data, and updating pointers. Insertion can occur at the beginning, end, or middle of the list."
    },
    {
      "summary_text": "To insert at the beginning: create a new node, set its `m_next` to the current head, and then update the head to point to the new node."
    },
    {
      "summary_text": "To traverse a linked list: start at the head, iterate through each node using a temporary pointer, and access/process the data until the pointer reaches `nullptr`."
    },
    {
      "summary_text": "Removing a node requires keeping track of the previous node. Update the previous node's `m_next` pointer to skip the node being removed, then deallocate the removed node's memory."
    },
    {
      "summary_text": "Dummy nodes are extra nodes at the beginning and/or end of a list that don't store data. These simplify operations by eliminating edge cases like empty lists."
    },
    {
      "summary_text": "Reversing a linked list involves updating each node's `m_next` pointer to point to the previous node. Requires three pointers: current, previous, and next, to avoid losing the list."
    }
  ]
}
