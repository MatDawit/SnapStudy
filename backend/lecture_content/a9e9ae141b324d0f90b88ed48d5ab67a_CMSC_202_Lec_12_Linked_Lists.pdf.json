{
  "deck_title": "CMSC202 Â· Linked Lists",
  "topics": [
    {
      "summary_text": "Linked lists are dynamic data structures that allow efficient insertion and deletion of elements. They consist of nodes, each containing data and a pointer to the next node. Unlike vectors, linked lists don't require contiguous memory blocks."
    },
    {
      "summary_text": "Vectors require time-consuming middle insertions/deletions and sorting. Linked lists change size easily, allowing insertions/deletions anywhere. However, random access is impossible, and memory management is required."
    },
    {
      "summary_text": "A node is a Linked List element with data and a pointer (`m_next`) to the next node. Nodes are often represented as classes."
    },
    {
      "summary_text": "The last node's pointer is `nullptr`. Each node links to another node or `nullptr`. Consider edge cases like empty or single-element lists."
    },
    {
      "summary_text": "Linked list operations require memory management to prevent losing nodes. Special cases (empty, single-element lists) need specific handling."
    },
    {
      "summary_text": "Essential Linked List functions: constructor, `insert()`, `remove()`, `printList()`, and `isEmpty()`."
    },
    {
      "summary_text": "A Linked List constructor initializes `m_head` to `nullptr`. Extended versions also set `m_tail` to `nullptr` and `m_size` to `0`."
    },
    {
      "summary_text": "Inserting a node: create a new node, populate it with data, and link it into the list. Insertion can happen at the beginning, end, or middle."
    },
    {
      "summary_text": "To traverse a linked list: start at `m_head`, loop until the current node is `nullptr`, process the data, and move to the next node using `m_next`."
    },
    {
      "summary_text": "Removing a node requires tracking the previous node to avoid breaking the list. Iterate with `curr` and `prev` pointers, relink, and then `delete curr`."
    },
    {
      "summary_text": "Dummy nodes alleviate edge case concerns by providing a persistent head and tail, simplifying operations and avoiding nullptr checks."
    },
    {
      "summary_text": "Reversing a linked list requires updating pointers. Use `curr`, `prev`, and `next` pointers to iterate, reverse the links, and move pointers to the next set of nodes."
    }
  ]
}
